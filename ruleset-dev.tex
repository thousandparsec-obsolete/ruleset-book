\documentclass[a4paper,11pt]{report}


% Title Page
\title{Ruleset Development with tpserver-cpp}
\author{Lee Begg}


%useful commands

%\filename{name}
\newcommand{\filename}[1]{\emph{#1}}

%\codename{variable} \codename{methodName()} \codename{DEF_NAME}
\newcommand{\codename}[1]{\texttt{#1}}


\begin{document}

%Start the doc

\maketitle

\tableofcontents

\begin{abstract}
The document outlines the process for developing rulesets for tpserver-cpp. Since the Thousand Parsec project overall and tpserver-cpp in particular are developing fast, this is a living document, changing as the tpserver-cpp environment changes.

Developing a ruleset is not a trivial process, so this document is designed to guide you through the steps
you need to do and highlight issues and probable sticking points. Hopefully it make ruleset development easy enough that several parallel ruleset developments can take place.
\end{abstract}

\part{The Big Picture}
\label{part:intro}

\chapter{Thousand Parsec}
\label{chap:tp}
Started in 2003 by mithro (Tim Ansell) and llnz (Lee Begg), at mithro's instigation, the project was aiming to become a framework for building online turn base space strategy games. Thousand Parsec was originally conceived as a ``Stars!'' clone, but taking inspiration from the WorldForge project---building a framework for creating massively multiplayer online role playing games---that both mithro and llnz worked on, it was decided to go for the much more general goal.


The framework can be divided into four areas.
\begin{itemize}
 \item Protocol
 \item Servers
 \item Clients
 \item Media
\end{itemize}

The protocol is described fully in chapter \ref{chap:protocol-intro}. Servers provide games using the TP protocol, and can do it in different ways. They can provide multiple games at once, and can host different games. Clients provide the user's view of the game. A client can connect to any server, and users should be able to use multiple different clients to connect to any game. The media collected by the project can be used by any game.

The whole framework is under development.

\chapter{Protocol}
\label{chap:protocol-intro}

The Thousand Parsec protocol is the truly defining work of Thousand Parsec. It sets the common understanding between servers and clients. If a game can work within the restrictions of the protocol then the whole Thousand Parsec framework can be used.

\chapter{Introduction to tpserver-cpp}
\label{chap:tpserver-cpp-intro}
tpserver-cpp is the software written in C++ for Thousand Parsec which implements a Thousand Parsec protocol Server. It was mostly designed and written by Lee Begg (llnz). In it's early days, Lee used it as the project for his Honours Level (4th year university) Software Engineering project.

It supports only one game at a time. It uses plugins (dynamically loaded libraries) to implement tpscheme (tpcl), persistence methods, and rulesets. It is currently single threaded, although that is very likely to change.

tpserver-cpp has a nice console terminal, using libtprl. Underneath, libtprl is a wrapper around Readline, so all readline editing features, and history, are available.

\chapter{Tools Used}
\label{chap:tools}

Thousand Parsec use a number of tools in creating it's framework. Some of those specific to tpserver-cpp are outlined below.

\section{Git/Cogito}
\label{sec:git}

Git is a distributed source revision control system. This allow many people to work simultaneously, even disconnected from the internet. Changes are recorded in snapshots, and are sent and push around. As it is used by the Linux Kernel, it is developing and well supported.

A slightly nicer interface to git is Cogito, with commands starting with ``\filename{cg-}''.

\section{Autotools}
\label{sec:autotools}

The collection of aclocal, autoheader, autoconf, and automake make up ``autotools''. They are mostly used with C and C++ based projects, providing a slightly nicer way of configuring the build environment and build system than by scratch (in for example, sh/m4 and Makefile).

A replacement for autotools is not out of the question because of the complexity of using autotools and some platforms are not well supported.

\subsection{Libtool}
\label{sec:libtool}

Libtool is also consided part of autotools. It provides a generic way to create libraries and dynamic module loading programs.

Because libtool was so wonderful in creating loadable libraries on many platforms and the lack of a common way to load said libraries, libtool has a companion library called libltdl---the libtool Dynamic Loader.  It has an interface similar to \codename{dlopen()} that works on all the systems libtool does. This includes systems that don't actually dynamically load, so libtool and libltdl have hacks to allow what looks like dynamic loading, but isn't.


\part{Starting out}
\label{part:starting}

\chapter{Building tpserver-cpp}
\label{chap:building-tpserver-cpp}

README, INSTALL, man page.

tpserver-cpp uses libtprl for the console in the server. Only libtprl is required to build tpserver-cpp, all other packages mentioned are optional.


To build tpserver-cpp, first you will need libtprl installed. If you distribution has a high enough version of the library, you should install that. Otherwise you will need to build from source.

% describe building libtprl here


With libtprl installed, we can now build tpserver-cpp itself. The first set is to get the source for the server, either from a release, or from the bleeding edge git repository.

If you choose to start with a released version of tpserver-cpp, download the tarball (\filename{tar.gz} files), and then you can run the following commands:

\begin{verbatim}
 >$ tar xzf tpserver-cpp-<version>.tar.gz
 >$ cd tpserver-cpp-<version>
\end{verbatim}

If you chose to build the current bleeding edge from git, you need to clone the repository and set up the build environment.

\begin{verbatim}
 >$ cg-clone git://git.thousandparsec.net/git/tpserver-cpp.git
 >$ cd tpserver-cpp
\end{verbatim}

This downloads the source from the git repo.
Then the first time, and any time a \filename{.in}, \filename{.ac} or \filename{.am} file changes, you need to run \filename{autogen.sh} to generate the configure script, and create the build system.

\begin{verbatim}
 >$ ./autogen.sh
\end{verbatim}

Now both the released tarball and the bleeding edge from git are ready to be configured and built.

The configure script takes a number of options and settings. Running \codename{./configure} with the  \codename{--help} option prints out information about the various options. Some of the important options are highlighted in \filename{README}. Some environmental variables are also recorded by configure, among these is \codename{PKG\_CONFIG\_PATH} which can be used to help the \filename{configure} script find libtprl. For example, if you prefix for libtprl is \filename{/opt/tp/}, the you should run \codename{PKG\_CONFIG\_PATH=/opt/tp/lib/pkg\_config ./configure}.


\begin{verbatim}
 >$ ./configure
 >$ make
 ># make install
\end{verbatim}

\chapter{Configuring tpserver-cpp}
\label{chap:configure}

Once tpserver-cpp is built and installed, you can run tpserver-cpp.  You won't see much though as the default configuration is very basic.

The settings for the server can be specified on the command line, read from file, or entered on the console. The settings are recorded in that order, so the file overwrites the command line for example.

All the settings are defined and described in the \filename{sample.conf} files. Some modules have the own \filename{sample.conf} files as well.

\chapter{Basic Design}
\label{chap:design-basic}

The tpserver-cpp source tree is divided into two parts. The first part, ``\filename{tpserver}'' is the core of the server and implements all the common parts of the server. The second part is the ``\filename{modules}'' tree.

Also in the root directory is a copy of libltdl because some distributions (namely debian and ubuntu) ship broken versions.

\section{\filename{tpserver} tree}
\label{sec:tree-tpserver}

This tree contains the bulk of the server.

\section{\filename{modules} tree}
\label{sec:tree-modules}

The \filename{modules} tree contains the modules the server ships with. They are divided by the type of module they are, namely ``\filename{game}'' for rulesets, ``\filename{persistence}'' for persistence methods, and ``\filename{tpscheme}'' for scheme implementations.

\part{Ruleset Development}
\label{part:ruleset-dev}

\chapter{The Ruleset Concept}
\label{chap:ruleset-concept}

In tpserver-cpp, rulesets define how the game behaves.  All the properties and rules which define the game are in the ruleset.

The core server implements all the things that are common between rulesets. This includes how to talk to clients, how to cache the data between clients and persistence, and what the various data types look like.



\chapter{Ruleset parts in tpserver-cpp}
\label{chap:ruleset-parts}

The development of a ruleset can be broken down into parts. Some of the parts are related to a single class, where others touch on many classes.

\section{\codename{Ruleset} Class}
\label{sec:ruleset-class}

The \codename{Ruleset} class is the ``public face'' of the ruleset. It handles a few tasks relating to the initialisation, creating and running the game, and players.

Two functions, \codename{getName()} and \codename{getVersion()} are used to provide the name and version of the ruleset, and is used to publish the ruleset name to the metaserver and to DNS-SD on the local network.

The \codename{initGame()} method sets the server up ready for the game to be created or resumed from persistence.

The \codename{createGame()} creates everything to start the game with. This includes creating the universe, initialising all the components and properties, and anything else that only has to be done once so the game can be played.

The method \codename{startGame()} is called when the game is made active and in progress, including everytime the server is started with the game already created and in persistence.

Two functions handle the creation of player for the ruleset.  The function \codename{onPlayerAdd()} allows the ruleset to decide if the player is allowed to be added. Most of the time they will be allowed, but if there is limited number of players then the ruleset can say no to creating the new player. The method \codename{onPlayerAdded()} allows the ruleset to do things---such as give the player a home planet---now that the player has been added to the game.

\section{\codename{TurnProcess} Class}
\label{sec:turn-process}

The \codename{TurnProcess} class is used to perform the tasks required to end the turn. As such, the virtual method called is \codename{doTurn()}.  Other methods might be provided to subclasses in future to simplify and optimise the turn processing.

\section{Object Types}
\label{sec:object-types}

The object types define the properties of objects that appear in the universe.

\section{Order Types}
\label{sec:order-types}

Order types define what actions objects can take.

In the End of Turn process, the method \codename{doOrder()} is called, where the actual work is done.

\section{Categories, Designs, Components and Properties}
\label{sec:designs-components-properties}

\chapter{Where to Begin}
\label{chap:begin}

A ruleset normally starts simply with an idea. This could be wanting to implement an existing game in any format, or it could be a concept for an all new game.

The next step is to plan out as much of the game as possible. Gathering or creating as much information as possible about what is in the game helps later on. Information includes: what object types, what orders can be given to those objects, what order things a processed at the end of turn, what types of designs can be made, what components those designs are made of, and what properties are needed for those designs and components.  Also needed is how combat will be resolved if the game includes it.
Another important element of any idea is the name that the ruleset will be called.


The third step is to code, and the fourth is test, followed by more coding and testing.


\chapter{Setting up the Build System}
\label{chap:build-system}

The build system is the process used to create the ruleset module from the source code. The method used varies if you build your module in the tpserver-cpp source tree, or you build it in its own separate source tree.



\section{In Tree Modules}
\label{sec:intree-module-build}

In tree modules, such as the provided Minisec and MTSec rulesets, use the tpserver-cpp build system. This system is build on Autoconf and Automake.  The first step is to make a directory in the \filename{modules/games/} directory to hold the source code for the module. 

\begin{verbatim}
 >$ cd modules/games
 >$ mkdir mygame
\end{verbatim}

Next, you need to create a \filename{Makefile.am} file in the new directory. It's contents should be something like:

\begin{verbatim}
rulesetlib_LTLIBRARIES = libmygame.la

rulesetlibdir = $(libdir)/tpserver/ruleset

libmygame_la_SOURCES = mygame.cpp

libmygame_la_LDFLAGS = -module

noinst_HEADERS = mygame.h
\end{verbatim}

As you add more source files, you add the \filename{\.cpp} files to \codename{SOURCES}, and the header files to \codename{noinst\_HEADERS}. You can break long lines onto multiple lines by putting a backslash (\verb|\|) at the end of the line and continuing on the next line. Note that the \codename{SOURCES} and \codename{LDFLAGS} variables start with the name of the library with underscore instead of the fullstop.

Lastly, we need the build system to actually process the new directory with it's \filename{Makefile.am} file. Two files need to be change. The first is to add the new directory to the \codename{SUBDIRS} of \filename{modules/games/Makefile.am}, such as:

\begin{verbatim}
SUBDIRS = mtsec minisec mygame
\end{verbatim}

The second file that needs changing is \filename{configure.ac}. This file needs to know about the \filename{Makefile.am} file to make it into first \filename{Makefile.in} and then a normal \filename{Makefile}. We add a line about our new \filename{Makefile.am} in the \codename{AC\_CONFIG\_FILES} section that is right at the end of \filename{configure.ac} file:

\begin{verbatim}
AC_CONFIG_FILES([
Makefile
tpserver/Makefile
modules/Makefile
modules/games/Makefile
modules/games/minisec/Makefile
modules/games/mtsec/Makefile
modules/persistence/Makefile
modules/persistence/mysql/Makefile
modules/tpcl/Makefile
modules/tpcl/guile/Makefile
modules/tpcl/mzscheme/Makefile
modules/games/mygame/Makefile
]) 
\end{verbatim}

Now the build system is ready for the code for the ruleset to be written. You will need to run \codename{./autogen.sh} and \codename{./configure} each time you edit your \filename{Makefile.am}, so it would be a good idea to do that now. Note that because it specifies \filename{mygame.cpp} as a source file and we haven't created it yet, the build system will not make the ruleset module.

\section{Out of Tree Modules}
\label{sec:outoftree-module-build}

You can use any build system you want if you are building out of tree. One point to keep in mind though is the location that the ruleset module needs to be installed to. It should match the location expected by tpserver-cpp. Typical locations could be one of the following:
\begin{itemize}
 \item \filename{/usr/lib/tpserver/ruleset/}
 \item \filename{/usr/local/lib/tpserver/ruleset/}
 \item \filename{/opt/tp/lib/tpserver/ruleset/}
 \item \filename{\$PREFIX/lib/tpserver/ruleset/}
\end{itemize}

If the ruleset module isn't installed in the correct location, the name of the ruleset in the settings will need to include the path to the module. For example:

\begin{verbatim}
#Ruleset module installed in /usr/local/lib/mygamename/
#while server expects them in /usr/lib/tpserver/rulesets/

ruleset = "/usr/local/lib/mygamename/libmyruleset"

#compare with the following
#ruleset = myruleset
\end{verbatim}

As can be seen, it is preferable to have the ruleset module installed in the right place to make configuring easier for game admins to set up games. But using the path can be handy in testing the ruleset without having to install it after every change.

\chapter{Writing the Ruleset}
\label{chap:ruleset-writing}


\end{document}
